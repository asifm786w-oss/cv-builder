diff a/App.py b/App.py	(rejected hunks)
@@ -12,50 +12,51 @@ import traceback
 from datetime import datetime, timezone
 
 import streamlit as st
 import requests
 import stripe
 import psycopg2
 import psycopg2.extras
 from psycopg2.extras import RealDictCursor
 
 from openai import OpenAI
 
 from db import get_conn, get_db_connection, fetchone, fetchall, execute
 
 from utils import verify_postgres_connection
 from models import CV, Experience, Education
 from utils import (
     render_cv_pdf_bytes,
     render_cover_letter_pdf_bytes,
     render_cv_docx_bytes,
     render_cover_letter_docx_bytes,
 )
 from ai_v2 import (
     generate_tailored_summary,
     generate_cover_letter_ai,
     improve_bullets,
+    improve_skills,
     extract_cv_data,
     generate_job_summary,
 )
 from auth import (
     init_db,
     create_user,
     authenticate_user,
     increment_usage,
     get_all_users,
     set_plan,
     get_user_by_email,
     create_password_reset_token,
     reset_password_with_token,
     ensure_referral_code,
     get_user_by_referral_code,
     apply_referral_bonus,
     has_accepted_policies,
     mark_policies_accepted,
     set_role,
     set_banned,
     delete_user,
 )
 
 from email_utils import send_password_reset_email
 
@@ -177,105 +178,106 @@ DEFAULT_SESSION_KEYS = {
     "_policies_loaded": False,
     "_policies": {},
 
     # job search cache
     "adzuna_results": [],
 
     # CV upload cache (stable across reruns)
     "cv_upload_bytes": None,
     "cv_upload_name": None,
 }
 
 for k, v in DEFAULT_SESSION_KEYS.items():
     st.session_state.setdefault(k, v)
 
 # DB init stays here (once)
 init_db()
 verify_postgres_connection()
 
 # ============================================================
 # PROTECTED STATE (NEVER CLEAR MID-SESSION)
 # ============================================================
 PROTECTED_EXACT_KEYS = {
     # auth/user
     "user", "user_id", "accepted_policies", "chk_policy_agree",
 
-    # CV inputs
-    "skills_text", "references", "job_description", "template_label",
-
-    # job search
-    "adzuna_keywords", "adzuna_location", "adzuna_results", "selected_job",
-
-    # AI outputs you want to persist
+    # persistent system caches / derived outputs
+    "adzuna_results", "selected_job",
     "job_summary_ai", "cover_letter", "cover_letter_box",
-
-    # structure
-    "num_experiences", "parsed_num_experiences", "num_education", "education_items",
-
-    # cached upload payload
+    "education_items", "parsed_num_experiences",
     "cv_upload_bytes", "cv_upload_name",
 }
-# Keys that belong to Streamlit widgets and must never be programmatically restored
-NON_RESTORABLE_KEYS = {
-    "cv_uploader",   # file_uploader widget key
+
+# Widget keys must never be restored from snapshots.
+WIDGET_EXACT_KEYS = {
+    "cv_uploader",
+    "skills_text", "references", "job_description", "template_label",
+    "num_experiences", "num_education",
+    "adzuna_keywords", "adzuna_location",
 }
 
-PROTECTED_PREFIXES = (
-    # personal
+WIDGET_PREFIXES = (
     "cv_",
-
-    # experience
     "job_title_", "company_", "exp_location_", "start_date_", "end_date_", "description_",
-
-    # education
     "degree_", "institution_", "edu_location_", "edu_start_", "edu_end_",
+    "auth_", "btn_", "gate_open_", "footer_open_", "use_job_",
+)
+
+SYSTEM_PREFIXES = (
+    "_cooldown_",
 )
 
 def is_protected_key(k: str) -> bool:
     if k in PROTECTED_EXACT_KEYS:
         return True
-    return any(k.startswith(p) for p in PROTECTED_PREFIXES)
+    return any(k.startswith(p) for p in SYSTEM_PREFIXES)
+
+
+def is_widget_key(k: str) -> bool:
+    if k in WIDGET_EXACT_KEYS:
+        return True
+    return any(k.startswith(p) for p in WIDGET_PREFIXES)
 
 # ---------- Snapshot / restore (extra safety; useful around clears) ----------
 def snapshot_protected_state(label=None):
     snap = {}
     for k, v in st.session_state.items():
-        if k in NON_RESTORABLE_KEYS:
+        if is_widget_key(k):
             continue
-        if k in PROTECTED_EXACT_KEYS or any(k.startswith(p) for p in PROTECTED_PREFIXES):
+        if is_protected_key(k):
             snap[k] = v
 
     st.session_state["_protected_snapshot"] = snap
     if label:
         st.session_state["_protected_snapshot_label"] = label
     return snap
 
 def restore_protected_state(snap: dict) -> None:
     if not isinstance(snap, dict):
         return
     for k, v in snap.items():
-        if k in NON_RESTORABLE_KEYS:
+        if is_widget_key(k):
             continue
         st.session_state[k] = v	
 	
 
 def _safe_set(k, v):
     if v is None:
         return
     if isinstance(v, str) and not v.strip():
         return
     cur = st.session_state.get(k)
     if cur is None or (isinstance(cur, str) and not cur.strip()):
         st.session_state[k] = v.strip() if isinstance(v, str) else v
 
 # ---------- Safe session ops ----------
 def safe_pop_state(k: str) -> None:
     if is_protected_key(k):
         return
     st.session_state.pop(k, None)
 
 def safe_clear_state(keys: list[str]) -> None:
     for k in keys:
         safe_pop_state(k)
 
 def safe_init_key(key: str, default=""):
     if key not in st.session_state or st.session_state[key] is None:
@@ -287,74 +289,50 @@ def stage_value(key: str, value):
 def apply_staged_value(key: str):
     pk = f"__pending__{key}"
     if pk in st.session_state:
         st.session_state[key] = st.session_state.pop(pk)
 
 def safe_set_if_missing(key: str, value, *, strip: bool = True):
     cur = st.session_state.get(key)
     cur_s = (cur or "").strip() if isinstance(cur, str) else cur
     if cur is None or cur_s == "":
         if isinstance(value, str) and strip:
             value = value.strip()
         if value is not None:
             st.session_state[key] = value
 
 # ---------- Word limit helper (you call this in multiple places) ----------
 def enforce_word_limit(text: str, max_words: int, label: str = "") -> str:
     words = (text or "").split()
     if len(words) > int(max_words):
         st.warning(
             f"{label or 'Text'} is limited to {max_words} words. "
             f"Currently {len(words)}; extra words are ignored."
         )
         return " ".join(words[: int(max_words)])
     return text or ""
 
-# ---------- Output-only resets (aliases to match your calls) ----------
-def reset_outputs_only() -> None:
-    """
-    Clear ONLY derived/transient outputs.
-    Never clears user inputs.
-    """
-    snap = snapshot_protected_state()   # ✅ now returns dict
-    safe_clear_state([
-        "_cv_parsed",
-        "_cv_autofill_enabled",
-        "_just_autofilled_from_cv",
-        "_last_cv_fingerprint",
-        "generated_cv",
-        "generated_cover_letter",
-        "generated_summary",
-        "suggested_bullets",
-        "ats_score",
-        "final_pdf_bytes",
-        "final_docx_bytes",
-        "selected_template",
-        "download_ready",
-    ])
-    restore_protected_state(snap)       # ✅ restores properly
-
 # ---------- User ID helpers (NO recursion, no globals tricks) ----------
 def get_user_id_by_email(email: str) -> int | None:
     email = (email or "").strip().lower()
     if not email:
         return None
     row = fetchone(
         "SELECT id FROM users WHERE LOWER(email)=LOWER(%s) LIMIT 1",
         (email,),
     )
     if not row:
         return None
     try:
         return int(row["id"])
     except Exception:
         return None
 
 def get_user_id(email: str) -> int | None:
     return get_user_id_by_email(email)
 
 # ============================================================
 # LEDGER CREDITS — SINGLE SOURCE OF TRUTH (NO NAME CLASH)
 # - supports BOTH styles:
 #     spend_credits(conn, uid, source=..., cv_amount=1)
 #     spend_credits(uid, source=..., cv=1)
 # - fixes: unexpected keyword 'cv_amount'
